digraph Issue {
  // Generic pipeline for GitHub issues.
  // Usage: ISSUE_URL=https://github.com/reymarx/localrank-city/issues/57 bun run run.ts issue.dot
  // Or:    ISSUE_NUMBER=57 REPO=/home/rey/clawd/localrank-city bun run run.ts issue.dot

  graph [goal="$ISSUE_URL"]

  start [shape=Mdiamond]
  exit  [shape=Msquare]

  plan [label="Plan", prompt="You are a senior software engineer. Your task: $goal\n\n0. If PROJECT_ID is set, move the issue to In Progress on the project board using GitHub GraphQL (see example below).\n   - Find the project item ID for this issue number\n   - Update Status field to In Progress\n\n   Example (adjust IDs):\n   gh api graphql -f query='\n   {\n     node(id: \"$PROJECT_ID\") {\n       ... on ProjectV2 {\n         items(first: 50) {\n           nodes {\n             id\n             content { ... on Issue { number } }\n           }\n         }\n       }\n     }\n   }'\n\n   Then:\n   gh api graphql -f query='\n   mutation {\n     updateProjectV2ItemFieldValue(input: {\n       projectId: \"$PROJECT_ID\"\n       itemId: \"$PROJECT_ITEM_ID\"\n       fieldId: \"$STATUS_FIELD_ID\"\n       value: { singleSelectOptionId: \"$STATUS_IN_PROGRESS_ID\" }\n     }) { projectV2Item { id } }\n   }'\n\n1. Use exec to run: gh issue view $ISSUE_NUMBER --repo $REPO_SLUG --json title,body,labels,comments | head -200\n2. Use read to explore the codebase at $REPO_PATH. Read the directory structure, key files, and existing patterns.\n3. Output a detailed, step-by-step implementation plan. Include: files to create/modify, data models, API routes, UI components, validation, error handling, and tests.\n4. Be specific â€” reference actual file paths, function names, and patterns from the existing code."]

  implement [label="Implement", prompt="You are a senior software engineer working in $REPO_PATH.\nYour task: $goal\n\n1. First, read the plan from the previous stage if available.\n2. Use exec to run: gh issue view $ISSUE_NUMBER --repo $REPO_SLUG --json title,body | head -100\n3. Explore the codebase: read relevant existing files to understand patterns, imports, and conventions.\n4. Implement the feature using write and edit tools. Follow existing code patterns exactly.\n5. Include proper TypeScript types, Zod validation, error handling, and security (CSRF, rate limiting) where applicable.\n6. Write unit tests covering happy path, validation errors, edge cases, and error handling."]

  test [label="Test", prompt="You are a senior software engineer working in $REPO_PATH.\n\n1. Run the test suite: exec cd $REPO_PATH && npx jest --passWithNoTests 2>&1 | tail -40\n2. If any tests FAIL, read the failing test files and source files, fix the issues, then re-run.\n3. Run type checking: exec cd $REPO_PATH && npx tsc --noEmit 2>&1 | tail -40\n4. If there are type errors, fix them and re-run.\n5. Repeat until both tests and types pass clean."]

  review [label="Review", prompt="You are a senior code reviewer examining changes in $REPO_PATH.\n\n1. Run: exec cd $REPO_PATH && git diff HEAD --stat\n2. Run: exec cd $REPO_PATH && git diff HEAD\n3. Review all changes for:\n   - Security issues (XSS, injection, CSRF, auth bypass)\n   - Missing error handling or edge cases\n   - Code that doesn't follow existing patterns\n   - Missing or inadequate tests\n   - TypeScript type safety (any usage, missing types)\n   - Performance concerns\n4. If you find issues, fix them using edit/write tools.\n5. Re-run tests after any fixes: exec cd $REPO_PATH && npx jest --passWithNoTests 2>&1 | tail -20\n6. If PROJECT_ID is set, move the issue to Review on the project board (same GraphQL approach as plan stage, using $STATUS_REVIEW_ID).\n7. Summarize what was implemented and any concerns."]

  start -> plan -> implement -> test -> review -> exit

  // Retry edges
  implement -> test [label="tests fail", condition="outcome=fail"]
}
