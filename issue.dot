digraph Issue {
  // Improved generic pipeline for GitHub issues.
  // Stages communicate via .factory/ artifacts — each stage reads the previous stage's output.
  //
  // Usage:
  //   ISSUE_NUMBER=57 REPO_PATH=/path/to/repo bun run run.ts issue.dot
  //   Or via wrapper: ./run-issue.sh 57 /path/to/repo
  //
  // Required env vars: ISSUE_NUMBER, ISSUE_URL, REPO_PATH, REPO_SLUG
  // Optional env vars: PROJECT_ID, STATUS_FIELD_ID, STATUS_IN_PROGRESS_ID, STATUS_REVIEW_ID

  graph [goal="$ISSUE_URL", default_max_retry="2"]

  start [shape=Mdiamond]
  exit  [shape=Msquare]

  setup [label="Setup", prompt="You are a senior software engineer preparing to work on a GitHub issue.\n\n1. Set up a clean feature branch:\n   cd $REPO_PATH && git checkout main && git pull origin main\n   git checkout -b fix/$ISSUE_NUMBER\n\n2. Read the issue:\n   gh issue view $ISSUE_NUMBER --repo $REPO_SLUG --json title,body,labels,comments\n\n3. Create the artifacts directory:\n   mkdir -p $REPO_PATH/.factory\n\n4. Write $REPO_PATH/.factory/issue.md with:\n   - Issue title and number\n   - Full description\n   - Acceptance criteria (extract from body)\n   - Relevant comments\n\n5. Explore the codebase: read directory structure, key config files (package.json, tsconfig), and files relevant to this issue.\n\n6. Write $REPO_PATH/.factory/context.md with:\n   - Project structure overview\n   - Relevant file paths and their purposes\n   - Existing patterns, imports, and conventions the implementation should follow\n   - Tech stack details relevant to this issue"]

  plan [label="Plan", prompt="You are a senior software engineer creating an implementation plan.\n\n1. Read $REPO_PATH/.factory/issue.md and $REPO_PATH/.factory/context.md\n\n2. Create a detailed, step-by-step implementation plan and write it to $REPO_PATH/.factory/plan.md\n   Include:\n   - Files to create or modify (exact paths)\n   - Data models, API routes, UI components as needed\n   - Validation, error handling, security considerations\n   - Test strategy: what to test, edge cases, expected test count\n   - Reference actual function names and patterns from context.md\n\n3. The plan must be specific enough that another engineer could implement it without reading the issue again."]

  implement [label="Implement", prompt="You are a senior software engineer implementing a feature in $REPO_PATH on branch fix/$ISSUE_NUMBER.\n\n1. Read $REPO_PATH/.factory/plan.md — this is your spec. Follow it closely.\n2. If $REPO_PATH/.factory/feedback.md exists, read it — it contains feedback from a failed test run. Address every item.\n3. Implement the changes using write and edit tools. Follow existing code patterns exactly.\n4. Include proper TypeScript types, Zod validation, error handling, and security (CSRF, rate limiting, input sanitization) where applicable.\n5. Write unit tests covering: happy path, validation errors, edge cases, and error handling.\n6. Do NOT commit yet — the test stage will verify your work."]

  test [label="Test", prompt="You are a senior software engineer verifying code changes in $REPO_PATH on branch fix/$ISSUE_NUMBER.\n\n1. Run the test suite:\n   cd $REPO_PATH && npx jest --passWithNoTests 2>&1 | tail -60\n\n2. If tests FAIL:\n   - Read the failing test files and source files\n   - Try to fix the issues\n   - Re-run tests\n   - If you cannot fix them after 2 attempts, write the failures to $REPO_PATH/.factory/feedback.md with:\n     - Which tests failed and why\n     - What you tried\n     - What the implement stage should do differently\n   - Then output STAGE_FAILED\n\n3. Run type checking:\n   cd $REPO_PATH && npx tsc --noEmit 2>&1 | tail -50\n\n4. If type errors exist:\n   - Try to fix them\n   - If unfixable, append to $REPO_PATH/.factory/feedback.md and output STAGE_FAILED\n\n5. Run linting:\n   cd $REPO_PATH && npx eslint src/ 2>&1 | tail -30\n\n6. Fix any lint errors.\n\n7. Only if ALL checks pass (tests, types, lint), confirm success.\n   If any check still fails after your attempts, output STAGE_FAILED."]

  review [label="Review", prompt="You are a senior code reviewer examining changes in $REPO_PATH on branch fix/$ISSUE_NUMBER.\n\n1. Stage all changes:\n   cd $REPO_PATH && git add -A\n\n2. Review the diff:\n   git diff --cached --stat\n   git diff --cached\n\n3. Read $REPO_PATH/.factory/issue.md to verify changes address the requirements.\n\n4. Check for:\n   - Security issues (XSS, injection, CSRF, auth bypass)\n   - Missing error handling or edge cases\n   - Code that doesn't follow existing patterns\n   - Missing or inadequate tests\n   - TypeScript type safety (any usage, missing types)\n   - Performance concerns\n\n5. If you find issues, fix them with edit/write tools, then re-run:\n   cd $REPO_PATH && npx jest --passWithNoTests 2>&1 | tail -20\n\n6. Write a summary to $REPO_PATH/.factory/review.md:\n   - What was implemented\n   - What was fixed during review\n   - Any remaining concerns or follow-up items"]

  publish [label="Publish", prompt="You are a senior software engineer finalizing work in $REPO_PATH on branch fix/$ISSUE_NUMBER.\n\n1. Stage and commit (exclude .factory/ artifacts):\n   cd $REPO_PATH && git add -A -- ':!.factory'\n   git commit -m \"fix: resolve issue #$ISSUE_NUMBER\"\n\n2. Push the branch:\n   git push -u origin fix/$ISSUE_NUMBER\n\n3. Read $REPO_PATH/.factory/review.md for the PR body.\n\n4. Open a pull request:\n   gh pr create --repo $REPO_SLUG --base main --head fix/$ISSUE_NUMBER \\\n     --title \"Fix #$ISSUE_NUMBER\" \\\n     --body \"Closes #$ISSUE_NUMBER\n\n$(cat $REPO_PATH/.factory/review.md)\"\n\n5. Clean up artifacts:\n   rm -rf $REPO_PATH/.factory\n\n6. Output the PR URL."]

  // Pipeline flow
  start -> setup -> plan -> implement -> test -> review -> publish -> exit

  // Retry: if test fails, feed back to implement with feedback.md
  test -> implement [label="tests fail", condition="outcome=fail"]
}
