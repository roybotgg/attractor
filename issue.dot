digraph Issue {
  // Improved generic pipeline for GitHub issues.
  // Stages communicate via .factory/ artifacts — each stage reads the previous stage's output.
  //
  // Usage:
  //   ISSUE_NUMBER=57 REPO_PATH=/path/to/repo bun run run.ts issue.dot
  //   Or via wrapper: ./run-issue.sh 57 /path/to/repo
  //
  // Required env vars: ISSUE_NUMBER, ISSUE_URL, REPO_PATH, REPO_SLUG
  // Optional env vars: PROJECT_ID, STATUS_FIELD_ID, STATUS_IN_PROGRESS_ID, STATUS_REVIEW_ID

  graph [goal="$ISSUE_URL", default_max_retry="2"]

  start [shape=Mdiamond]
  exit  [shape=Msquare]

  setup [label="Setup", prompt="You are a senior software engineer preparing to work on a GitHub issue.\n\n**IMPORTANT: This stage is exploration only. Do NOT write any implementation code.**\n\n1. The feature branch is already checked out in $REPO_PATH (an isolated git worktree). Verify you are on the correct branch:\n   cd $REPO_PATH && git branch --show-current\n\n2. Read the issue:\n   gh issue view $ISSUE_NUMBER --repo $REPO_SLUG --json title,body,labels,comments\n\n3. Create the artifacts directory:\n   mkdir -p $REPO_PATH/.factory\n\n4. Extract and view any images/screenshots from the issue body:\n   - Look for <img> tags (src attribute) and markdown images ![alt](url) in the issue body\n   - For each image URL found, download it using authenticated curl (GitHub URLs require auth):\n     curl -sL -H \"Authorization: token $(gh auth token)\" \"<url>\" -o /tmp/issue-img-0.png (increment the number for each image)\n   - Use the read tool to view each downloaded image file — this lets you actually SEE the screenshot\n   - This step is critical for visual bugs (contrast, layout, color, alignment issues)\n   - If no images are found, skip this step\n\n5. Write $REPO_PATH/.factory/issue.md with:\n   - Issue title and number\n   - Full description\n   - Acceptance criteria (extract from body)\n   - Relevant comments\n   - **Visual Context** section: for each screenshot, describe what you see — UI elements, colors, layout problems, error states, circled/highlighted areas. Be specific (e.g. 'heading text appears light gray (#ededed) on white background, nearly invisible')\n\n6. Explore the codebase: read directory structure, key config files (package.json, tsconfig), and files relevant to this issue.\n\n7. Write $REPO_PATH/.factory/context.md with:\n   - Project structure overview\n   - Relevant file paths and their purposes\n   - Existing patterns, imports, and conventions the implementation should follow\n   - Tech stack details relevant to this issue\n   - **Known gotchas** from AGENTS.md or README (e.g. CosmosDB quirks, import restrictions, test patterns)"]

  plan [label="Plan", model="opus46", prompt="You are a senior software engineer creating an implementation plan.\n\n1. Read $REPO_PATH/.factory/issue.md and $REPO_PATH/.factory/context.md\n\n2. Create a detailed, step-by-step implementation plan and write it to $REPO_PATH/.factory/plan.md\n   Format each step as a checkbox for tracking progress:\n   - [ ] Step 1: Description (files: path/to/file.ts)\n   - [ ] Step 2: Description (files: path/to/other.ts)\n   Include:\n   - Files to create or modify (exact paths)\n   - Data models, API routes, UI components as needed\n   - Validation, error handling, security considerations\n   - Test strategy: what to test, edge cases, expected test count\n   - Reference actual function names and patterns from context.md\n\n3. The plan must be specific enough that another engineer could implement it without reading the issue again."]

  implement [label="Implement", prompt="You are a senior software engineer implementing a feature in $REPO_PATH (an isolated git worktree on its own branch).\n\n1. Read $REPO_PATH/.factory/plan.md — this is your spec. Follow it closely.\n2. If $REPO_PATH/.factory/feedback.md exists, read it — it contains feedback from a failed test run. Address every item.\n3. Check which steps are already marked [x] in plan.md — skip completed steps (from a prior interrupted run).\n4. Implement the changes using write and edit tools. Follow existing code patterns exactly.\n5. Include proper TypeScript types, Zod validation, error handling, and security (CSRF, rate limiting, input sanitization) where applicable.\n6. Write unit tests covering: happy path, validation errors, edge cases, and error handling.\n7. **After completing each plan step**, update plan.md to mark it done (change `- [ ]` to `- [x]`), then commit:\n   cd $REPO_PATH && git add -A -- ':!.factory' && git commit -m \"feat: <description>\"\n   This ensures progress is saved even if the pipeline is interrupted.\n8. Do NOT modify existing tests to make them pass — fix the implementation instead.\n9. After all implementation is done, run the tests yourself as a sanity check:\n   cd $REPO_PATH && npx jest --passWithNoTests 2>&1 | tail -20"]

  test [label="Test", model="quick", prompt="You are a senior QA engineer verifying code changes in $REPO_PATH (an isolated git worktree on its own branch).\n\n1. Run all quality checks in parallel to save time:\n   cd $REPO_PATH\n   npx jest --passWithNoTests > /tmp/test-results.txt 2>&1 &\n   npx tsc --noEmit > /tmp/typecheck-results.txt 2>&1 &\n   npx eslint src/ > /tmp/lint-results.txt 2>&1 &\n   wait\n\n2. Check results:\n   echo '=== TESTS ===' && tail -20 /tmp/test-results.txt\n   echo '=== TYPECHECK ===' && tail -20 /tmp/typecheck-results.txt\n   echo '=== LINT ===' && tail -20 /tmp/lint-results.txt\n\n3. If ALL checks pass, confirm success.\n\n4. If checks fail, triage each failure:\n   a. **Test-only issues** (wrong assertions, missing mocks, test setup, import paths in test files): Fix them directly.\n   b. **Trivial implementation issues** (typos, missing imports, wrong variable names): Fix them directly.\n   c. **Logic errors, missing features, architectural problems, or wrong behavior**: Do NOT fix these. Instead:\n      - Write detailed feedback to $REPO_PATH/.factory/feedback.md explaining:\n        - Which tests failed and the exact error messages\n        - Root cause analysis (what the implementation got wrong)\n        - What the implement stage should do differently\n      - Then output STAGE_FAILED\n\n5. After fixing test-only/trivial issues, re-run all checks to confirm they pass.\n\n6. Important: You are a verifier first. Only fix things you are confident are test infrastructure or trivial issues. When in doubt, write feedback and output STAGE_FAILED."]

  review [label="Review", model="opus46", prompt="You are a senior code reviewer examining changes in $REPO_PATH (an isolated git worktree on its own branch).\n\n1. Stage all changes:\n   cd $REPO_PATH && git add -A\n\n2. Review the diff:\n   git diff --cached --stat\n   git diff --cached\n\n3. Read $REPO_PATH/.factory/issue.md to verify changes address the requirements.\n\n4. Check for:\n   - Security issues (XSS, injection, CSRF, auth bypass)\n   - Missing error handling or edge cases\n   - Code that doesn't follow existing patterns\n   - Missing or inadequate tests\n   - TypeScript type safety (any usage, missing types)\n   - Performance concerns\n\n5. If you find issues, fix them with edit/write tools, then re-run:\n   cd $REPO_PATH && npx jest --passWithNoTests 2>&1 | tail -20\n\n6. Write a summary to $REPO_PATH/.factory/review.md:\n   - What was implemented\n   - What was fixed during review\n   - Any remaining concerns or follow-up items"]

  publish [label="Publish", prompt="You are a senior software engineer finalizing work in $REPO_PATH (an isolated git worktree).\n\n1. Get the current branch name and issue title:\n   cd $REPO_PATH && BRANCH=$(git branch --show-current)\n   ISSUE_TITLE=$(gh issue view $ISSUE_NUMBER --repo $REPO_SLUG --json title --jq .title)\n\n2. Stage any remaining changes (from review fixes) and commit:\n   cd $REPO_PATH && git add -A -- ':!.factory'\n   # Only commit if there are staged changes\n   git diff --cached --quiet || git commit -m \"fix: address review feedback for #$ISSUE_NUMBER\"\n\n3. Push the branch:\n   git push -u origin $BRANCH\n\n4. Read $REPO_PATH/.factory/review.md for the PR body.\n\n5. Open a pull request using the actual issue title:\n   gh pr create --repo $REPO_SLUG --base main --head $BRANCH \\\n     --title \"$ISSUE_TITLE (#$ISSUE_NUMBER)\" \\\n     --body \"Closes #$ISSUE_NUMBER\n\n$(cat $REPO_PATH/.factory/review.md)\"\n\n6. Clean up artifacts:\n   rm -rf $REPO_PATH/.factory\n\n7. Output the PR URL."]

  // Pipeline flow
  start -> setup -> plan -> implement -> test -> review -> publish -> exit

  // Retry: if test fails, feed back to implement with feedback.md
  test -> implement [label="tests fail", condition="outcome=fail"]
}
